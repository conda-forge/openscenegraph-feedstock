From 7b514efdd035af9593e13bf1885a7448d975e480 Mon Sep 17 00:00:00 2001
From: "Ying-Chun Liu (PaulLiu)" <paulliu@debian.org>
Date: Wed, 21 Sep 2022 01:56:56 +0800
Subject: [PATCH 4/5] Audio compatibility with ffmpeg 5

---
 src/osgPlugins/ffmpeg/FFmpegDecoderAudio.cpp | 24 +++++++++++++-------
 src/osgPlugins/ffmpeg/FFmpegPacket.hpp       |  2 +-
 2 files changed, 17 insertions(+), 9 deletions(-)

diff --git a/src/osgPlugins/ffmpeg/FFmpegDecoderAudio.cpp b/src/osgPlugins/ffmpeg/FFmpegDecoderAudio.cpp
index 636bddd25..afc2d4fe3 100644
--- a/src/osgPlugins/ffmpeg/FFmpegDecoderAudio.cpp
+++ b/src/osgPlugins/ffmpeg/FFmpegDecoderAudio.cpp
@@ -45,12 +45,19 @@ static int decode_audio(AVCodecContext *avctx, int16_t *samples,
     if (!frame)
         return AVERROR(ENOMEM);
 
-    ret = avcodec_decode_audio4(avctx, frame, &got_frame, &avpkt);
+    ret = avcodec_send_packet(avctx, &avpkt);
+    if (ret >= 0) {
+      ret = avcodec_receive_frame(avctx, frame);
+      if (ret == 0) {
+	got_frame = 1;
+      }
+    }
+
 
 #ifdef USE_AVRESAMPLE    // libav's AVFrame structure does not contain a 'channels' field
     if (ret >= 0 && got_frame) {
 #else
-    if (ret >= 0 && got_frame && av_frame_get_channels(frame)>0) {
+    if (ret >= 0 && got_frame && frame->ch_layout.nb_channels>0) {
 #endif
         int ch, plane_size;
         int planar = av_sample_fmt_is_planar(avctx->sample_fmt);
@@ -151,11 +158,13 @@ void FFmpegDecoderAudio::open(AVStream * const stream, FFmpegParameters* paramet
             return;
 
         m_stream = stream;
-        m_context = stream->codec;
+        AVCodecParameters* avp = stream->codecpar;
+        const AVCodec * p_codec = avcodec_find_decoder(avp->codec_id);
+        m_context = avcodec_alloc_context3(p_codec);
 
-        m_in_sample_rate = m_context->sample_rate;
-        m_in_nb_channels = m_context->channels;
-        m_in_sample_format = m_context->sample_fmt;
+        m_in_sample_rate = avp->sample_rate;
+        m_in_nb_channels = avp->channels;
+        m_in_sample_format = ((AVSampleFormat)(avp->format));
 
         AVDictionaryEntry *opt_out_sample_rate = av_dict_get( *parameters->getOptions(), "out_sample_rate", NULL, 0 );
         if ( opt_out_sample_rate )
@@ -210,11 +219,10 @@ printf("### CONVERTING from sample format %s TO %s\n\t\tFROM %d TO %d channels\n
         }
 
         // Check stream sanity
-        if (m_context->codec_id == AV_CODEC_ID_NONE)
+        if (avp->codec_id == AV_CODEC_ID_NONE)
             throw std::runtime_error("invalid audio codec");;
 
         // Find the decoder for the audio stream
-        AVCodec * const p_codec = avcodec_find_decoder(m_context->codec_id);
 
         if (p_codec == 0)
             throw std::runtime_error("avcodec_find_decoder() failed");
diff --git a/src/osgPlugins/ffmpeg/FFmpegPacket.hpp b/src/osgPlugins/ffmpeg/FFmpegPacket.hpp
index e06bd8bb6..94cc13b1b 100644
--- a/src/osgPlugins/ffmpeg/FFmpegPacket.hpp
+++ b/src/osgPlugins/ffmpeg/FFmpegPacket.hpp
@@ -42,7 +42,7 @@ namespace osgFFmpeg
         void clear()
         {
             if (packet.data != 0)
-                av_free_packet(&packet);
+                av_packet_unref(&packet);
 
             release();
         }
